---
title: "Introduction to censobr"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
urlcolor: blue
vignette: >
  %\VignetteIndexEntry{Introduction to censobr}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = identical(tolower(Sys.getenv("NOT_CRAN")), "true"),
  out.width = "100%"
)
```

**censobr** is an R package to download data from Brazil's Population Census. The package is built on top of the [Arrow platform](https://arrow.apache.org/docs/r/), which allows users to work with larger-than-memory census data using [{dplyr} familiar functions](https://arrow.apache.org/docs/r/articles/arrow.html#analyzing-arrow-data-with-dplyr).

*obs.:* The package is still under development. At the moment, censobr only includes microdata from the 2000 and 2010 censuses, but it is being expanded to cover more years and data sets.


## Installation

```R
# or use the development version with latest features
utils::remove.packages('censobr')
devtools::install_github("ipeaGIT/censobr")
library(censobr)
```


## Basic usage

The package currently includes 5 main functions to download Census microdata:

1. `read_population()`
2. `read_households()`
3. `read_mortality()`
4. `read_families()`
5. `read_emigration()`

The syntax of all **censobr** functions operate on the same logic so it becomes intuitive to download any data set using a single line of code. Like this:

```{r, eval = FALSE}
dfh <- read_households(
          year,          # year of reference
          columns,       # select columns to read
          add_labels,    # add labels to categorical variables
          as_data_frame, # return an Arrow DataSet or a data.frame
          showProgress,  # show download progress bar
          cache          # cache data for faster access later
         )
```

***Note:*** all data sets in **censobr** are enriched with geography columns following the name standards of the [{geobr} package](https://github.com/ipeaGIT/geobr/) to help data manipulation and integration with spatial data from the {geobr} package. The added columns are: `c(‘code_muni’, ‘code_state’, ‘abbrev_state’, ‘name_state’, ‘code_region’, ‘name_region’, ‘code_weighting’)`.


### Data cache

The first time the user runs a function, **censobr** will download the file and store it locally. This way, the data only needs to be downloaded once. When the `cache` parameter is set to `TRUE` (Default), the function will read the cached data, which is much faster. 

Users can list and/or delete data files cached locally using the `censobr_cache()` function:

```{r, eval=TRUE, warning=FALSE}
library(censobr)

# list cached files
censobr_cache(list_files = TRUE)
```

```{r, eval=TRUE, warning=FALSE}
# delete particular file
censobr_cache(delete_file = "2010_emigration")

```


## Larger-than-memory Data

Microdata of Brazilian census are often be too big to load in users' RAM memory. To avoid this problem, **censobr** will by default return an [Arrow table](https://arrow.apache.org/docs/r/articles/arrow.html#tabular-data-in-arrow), which can be analyzed like a regular `data.frame` using the `dplyr` package without loading the full data to memory.

Let's see how it works in a couple examples:


## Reproducible examples

First, let's load the libraries we'll be using in this vignette.

```{r, eval=TRUE, warning=FALSE}
library(censobr)
library(arrow)
library(dplyr)
library(geobr)
library(ggplot2)
```

#### Using Population data:

In this example we'll be calculating the proportion of people with higher education in different racial groups in the state of Rio de Janeiro. First, we need to use the `read_population()` function to download the population data set.

Since we don't need to load to memory all columns from the data, we can pass a vector the the columns we're going to use. This might be necessary in more constrained computing environments. Note that by setting `add_labels = 'pt'`, the function returns labeled values for categorical variables.

```{r, eval = TRUE, warning = FALSE}
pop <- read_population(year = 2010,
                       columns = c('abbrev_state', 'V0606', 'V0010', 'V6400'),
                       add_labels = 'pt',
                       showProgress = FALSE)

```

Next, we use the `dplyr` syntax to (a) filter observations for the state of Rio de Janeiro, (b) group observations by racial group, (c) summarize the data calculating the proportion of individuals with higher education.

```{r, eval = TRUE, warning = FALSE}
df <- pop |>
      filter(abbrev_state == "RJ") |>                                                    # (a)
      collect() |>
      group_by(V0606) |>                                                                 # (b)
      summarize(higher_edu = sum(V0010[which(V6400=="Superior completo")]) / sum(V0010), # (c)
                pop = sum(V0010) ) |>
      collect()

head(df)
```
Now we only need to plot the results.

```{r, eval = TRUE}
df <- subset(df, V0606 != 'Ignorado')

ggplot() +
  geom_col(data = df, aes(x=V0606, y=higher_edu), fill = '#5c997e') +
  scale_y_continuous(name = 'Proportion with higher education',
                     labels = scales::percent) +
  labs(x = 'Cor/raça') +
  theme_classic()
  
```

#### Using household data:

In this example, we are going to map how much people spend with rent across different states in Brazil. First, we can easily download the households data set with the `read_households()` function.

```{r, eval = TRUE}
hs <- read_households(year = 2010, 
                      showProgress = FALSE)

```

Now we're going to (a) group observations by state, (b) calculate the average rent, and (c) collect the results.

```{r, eval = TRUE, warning = FALSE}
rent <- hs |> 
        collect() |>
        group_by(code_state) |>                                            # (a)
        summarize(avgrent=weighted.mean(x=V2011, w=V0010, na.rm=TRUE)) |>  # (b)
        collect()                                                          # (c)

head(rent)
```
In order to create a map with of these values, we are going to use the `geobr` package to download the geometries of Brazilian states.

```{r, eval = TRUE, warning = FALSE}
uf <- geobr::read_state(year = 2010, 
                        showProgress = FALSE)
head(uf)
```

Now we only need to merge the spatial data with our rent estimates and map the results.

```{r, eval = TRUE, warning = FALSE}
uf$code_state <- as.character(uf$code_state)
rent_sf <- left_join(uf, rent, by = 'code_state')

ggplot() +
  geom_sf(data = rent_sf, aes(fill = avgrent), color=NA) +
  scale_fill_distiller(palette = "Greens", direction = 1, 
                       name='Avgerage\nRent in R$') +
  theme_void()

```
